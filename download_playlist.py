import sys
import shutil
import subprocess
import re
import os.path
import os
import unicodedata

from configparser import ConfigParser

import mutagen.mp3
import mutagen.apev2
import mutagen.mp4

import ImportUtils

#TODO: Library.recentlyAdded(100) / .onDeck() / .all() / all tracks by artist

DOWNLOAD_TMP = '/tmp/plex_playlist_download/'
DELETE_REMOVED_TRACKS = True
MAX_QUERY_RESULTS = 1000

PLAYLIST_FOLDER_RE = re.compile(r'(.*\|)?(.+)')

CLEAN_FILE_CHARS_RE = re.compile(r'[^A-Za-z0-9!åäöÅÄÖÜüßéÉ\-\.\(\) ]+')
def clean_string(dirty_string):
    return unicodedata.normalize('NFD', CLEAN_FILE_CHARS_RE.sub('_', dirty_string).strip('_'))


export_base_directory = os.path.abspath(sys.argv[1])
assert os.path.isdir(export_base_directory), "Output folder does not exist"

DL_CONFIGURATION = ConfigParser()
DL_CONFIGURATION.read(os.path.join(export_base_directory, "plex_download.cfg"))

# https://trac.ffmpeg.org/wiki/Encode/MP3
transcode_quality = DL_CONFIGURATION.get('Format', 'quality', fallback=3)
transcode_codec = DL_CONFIGURATION.get('Format', 'codec', fallback='mp3')
transcode_extension = DL_CONFIGURATION.get('Format', 'container', fallback='mp3')

SUPPORTED_FORMATS = []
for format_entry in ImportUtils.unmarshal_cfg_list(DL_CONFIGURATION.get('Format', 'Supported formats')):
    SUPPORTED_FORMATS.append(tuple(format_entry.split('/')))

transcode_spec = (transcode_codec, transcode_extension)
assert len(SUPPORTED_FORMATS) > 0
assert transcode_spec in SUPPORTED_FORMATS

export_queries = ImportUtils.unmarshal_cfg_list(DL_CONFIGURATION.get('Source', 'playlists'))

CONFIGURATION = ImportUtils.get_configuration()

plex = ImportUtils.PlexWrapper(CONFIGURATION)
MUSIC_SECTION = plex.server.library.section('Music')


class ExistingTrack():
    @classmethod
    def get_if_valid(_, full_path):
        _, extension = os.path.splitext(full_path)
        extension = extension[1:]
        for _, sext in SUPPORTED_FORMATS:
            if extension == sext:
                return ExistingTrack(full_path)
                
        return None
        
    def __init__(self, full_path):
        self.dir_path, self.name = os.path.split(full_path)
        assert os.path.isfile(self.path())
        
    def path(self):
        assert self.dir_path
        assert self.name
        
        return os.path.join(self.dir_path, self.name)
        
    def delete(self):
        assert DELETE_REMOVED_TRACKS
        
        try:
            os.remove(self.path())
        except FileNotFoundError:
            print ("     %s already removed)" % str(self.path()))

        
        
class ExportDirectory(object):
    """Represents a directory for exporting, possibly containing pre-existing tracks"""
    
    def __init__(self, path):
        self.remaining_items = {}
        os.makedirs(path, exist_ok=True)

        for (_, _, filenames) in os.walk(path):
            for file in filenames:
                file_path = os.path.join(path, file)
                
                existing_track = ExistingTrack.get_if_valid(file_path)
                if existing_track:
                    self.remaining_items[unicodedata.normalize('NFD', existing_track.name)] = existing_track
            break
            
    def is_existing(self, track_name):
        """Return true/false whether track_name is an existing track in this folder"""
        
        assert track_name
        return track_name in self.remaining_items.keys()
        
    def check(self, track_name):
        """Tick off existing track that's been exported"""
        
        assert track_name
        del(self.remaining_items[track_name])
            
    def delete_remaining(self):
        # assert len(export_tracklist.items) > len(remaining_items)
        for _, existing_track in self.remaining_items.items():
            print ("   - %s" % existing_track.path())
            existing_track.delete()
            
            
class TrackList():
    """Base class for export track lists generated by a query to the Plex API"""
    
    # abstract base class - regex matches nothing
    invocation = re.compile(r'$^')
    
    #TODO: handle duplicate tracks

    @classmethod
    def get_if_applicable(cls, query):
        #     # return None if query doesn't match invocation
        #     # throw error if query not found/empty
        #     return
        query_match = cls.invocation.match(query)
        if query_match:
            smart_playlist = cls(query_match)
            assert smart_playlist.items
            return smart_playlist
            
        return None
        
    def export(self, export_base_directory_):
        self.directory = os.path.join(export_base_directory_, clean_string(str(self)))
        export_directory = ExportDirectory(self.directory)

        print ("**** Exporting %s" % str(self))
        for item in self.items:
            track = ExportTrack(item)
            
            if not export_directory.is_existing(track.export_name):
                track.download()
                track.export(self.directory)
                
                print ("   + %s" % str(track))
            else:
                # Preexisting track, skip
                export_directory.check(track.export_name)
        
        if DELETE_REMOVED_TRACKS:
            assert len(self.items) > len(export_directory.remaining_items)
            export_directory.delete_remaining()
            
class TracksFromYearTrackList(TrackList):
    """Get up to MAX_QUERY_RESULTS of tracks from the chosen year"""
    invocation = re.compile(r'\/year\/(\d{4})')
        
    def __init__(self, query_match):
        self.year = query_match.group(1)
        assert self.year
        self.items = MUSIC_SECTION.search(title=None, sort=None, maxresults=MAX_QUERY_RESULTS, libtype='track', year=self.year)
        
    def __str__(self):
        return str(self.year)
        
class AlbumTrackList(TrackList):
    """Get all tracks from album by artist"""
    invocation = re.compile(r'\/album\/(.+)\/(.+)')
    
    def __init__(self, query_match):
        album_title = query_match.group(1)
        artist_name = query_match.group(2)
        artist = MUSIC_SECTION.search(title=artist_name, sort=None, maxresults=1, libtype='artist')[0]
        assert artist
        
        all_albums = artist.albums()
        for album in all_albums:
            if album.title == album_title:
                self.album = album
                self.items = album.tracks()
                break
                
        assert self.album
    def __str__(self):
        return str(self.album.title)
    
        
class ArtistTrackList(TrackList):
    """Get all tracks from chosen artist"""
    invocation = re.compile(r'\/artist\/(.+)')
    
    def __init__(self, query_match):
        artist_name = query_match.group(1)
        
        self.artist = MUSIC_SECTION.search(title=artist_name, sort=None, maxresults=1, libtype='artist')[0]
        assert self.artist
        self.items = self.artist.tracks()
        
    def __str__(self):
        return str(self.artist.title)
        
class LatestTrackList(TrackList):
    """Get chosen number of latest tracks added to library"""
    invocation = re.compile(r'\/latest\/(\d+)')
    
    def __init__(self, query_match):
        max_items = int(query_match.group(1))
        assert max_items > 0
        assert max_items <= MAX_QUERY_RESULTS

        #sort (str) – column:dir; column can be any of {addedAt, originallyAvailableAt, lastViewedAt, titleSort, rating, mediaHeight, duration}. dir can be asc or desc (optional).
        self.items = MUSIC_SECTION.search(title=None, sort='addedAt:desc', maxresults=max_items, libtype='track')

        assert len(self.items) <= max_items
        
    def __str__(self):
        return str("Latest")
        
class NamedPlayList(TrackList):
    invocation = re.compile(r'\/playlist\/(.+)')
    
    def __init__(self, query_match):
        playlist_name = query_match.group(1)
        
        #TODO: permissive playlist name matching?
        self.playlist = plex.server.playlist(playlist_name)
        assert self.playlist
        
        self.items = self.playlist.items()
        
    def __str__(self):
        #Remove "folder" part before | in title, if present
        stripped_title = PLAYLIST_FOLDER_RE.match(self.playlist.title).group(2)
        return str(stripped_title)
        

export_tracklists = []

print ("Getting playlists from Plex server:")
for query in export_queries:
    tracklist = None
    
    for smart_playlist_type in TrackList.__subclasses__():
        tracklist = smart_playlist_type.get_if_applicable(query)
        if tracklist:
            export_tracklists.append(tracklist)
            print(str(tracklist))
            break
    
    # if no /type is given, assume it's the name of a playlist
    if not tracklist:
        catch_all = re.match(r'(.+)', query)
        export_tracklists.append(NamedPlayList(catch_all))

assert len(export_tracklists) == len(export_queries)
        
        
    
class ExportTrack():
    def __init__(self, plex_track):
        self.plex_track = plex_track
        
        if self.plex_track.title:
            self.title = self.plex_track.title
        else:
            self.title = "Untitled %d" % self.plex_track.ratingKey
        
        if self.plex_track.originalTitle and self.plex_track.originalTitle.lower() not in ImportUtils.EMPTY_ARTIST_NAMES:
            self.artist = self.plex_track.originalTitle
        elif self.plex_track.artist().title.lower() not in ImportUtils.EMPTY_ARTIST_NAMES:
            self.artist = self.plex_track.artist().title

        if self.plex_track.album().title.lower() not in ImportUtils.EMPTY_ALBUM_TITLES:
            self.album = self.plex_track.album().title
        
        assert len(self.plex_track.media) == 1
        media = self.plex_track.media[0]
        audio_format = (media.audioCodec, media.parts[0].container)
        self.download_container = media.container
        assert self.download_container
        if audio_format not in SUPPORTED_FORMATS:
            self.transcode_codec = transcode_codec
            if media.audioCodec == self.transcode_codec:
                self.transcode_codec = 'copy'
                
        self.hash = media.id
                
        self.export_name = clean_string(self.title)
        
        if self.artist:
            self.export_name += " - %s" % clean_string(self.artist)
                
        self.export_name += "."
                    
        if self.transcode_codec:
            self.export_name += transcode_extension
        else:
            self.export_name += self.download_container
        
    def download(self):
        download_name = clean_string("%s.%s" % (self.hash, self.download_container))
        self.download_path = os.path.join(DOWNLOAD_TMP, download_name)
        if not os.path.isfile(self.download_path):
            download_paths = self.plex_track.download(savepath=DOWNLOAD_TMP, keep_original_name=False)
            assert len(download_paths) == 1
            
            os.rename(download_paths[0], self.download_path)
            
            if not self.transcode_codec:
                self.__write_tags(self.download_container, self.download_path)
             
    def __write_tags(self, container, file):
        if container == 'mp3':
            try:
                tag_file = mutagen.id3.ID3(file)
            except mutagen.id3.ID3NoHeaderError:
                tag_file = mutagen.id3.ID3()
            tag_file.add(mutagen.id3.TIT2(text=self.title))
            if self.album:
                tag_file.add(mutagen.id3.TALB(text=self.album))
            if self.artist:
                tag_file.add(mutagen.id3.TPE1(text=self.artist))
            tag_file.save(file)
        elif container == 'aac':
            tag_file = mutagen.apev2.APEv2File(file)
            try:
                tag_file.add_tags()
            except mutagen.apev2.error:
                # error if file already has tags
                pass
        
            # http://wiki.hydrogenaud.io/index.php?title=APE_key
            tag_file.tags['Title'] = self.title
            if self.album:
                tag_file.tags['Album'] = self.album
        
            if self.artist:
                tag_file.tags['Artist'] = self.artist
        
            tag_file.save()
            
        elif container in ['mp4', 'm4a']:
            tag_file = mutagen.mp4.MP4(file)
            try:
                tag_file.add_tags()
            except mutagen.mp4.error:
                # error if file already has tags
                # print(tag_file.tags)
                pass
                
            tag_file.tags['©nam'] = self.title
            if self.album:
                tag_file.tags['©alb'] = self.album
        
            if self.artist:
                tag_file.tags['©ART'] = self.artist
        
            tag_file.save()

    def export_path(self, playlist_directory):
        return os.path.join(playlist_directory, self.export_name)
        
    def export(self, playlist_directory):
        export_path = self.export_path(playlist_directory)
        
        if self.transcode_codec:
            transcode_path = os.path.join(DOWNLOAD_TMP, "%s.%s" % (self.hash, transcode_extension))
            if not os.path.isfile(transcode_path):
                ff_args = ["ffmpeg", "-i"]
                ff_args.append(self.download_path)
                ff_args.append('-vn')
                ff_args.extend(["-c:a", self.transcode_codec])
                ff_args.extend(["-ac", "2"])
                ff_args.extend(["-q:a", str(transcode_quality)])
                ff_args.append(transcode_path)
                
                subprocess.run(ff_args)
                
            self.__write_tags(transcode_extension, transcode_path)
            assert shutil.copy(transcode_path, export_path)

        else:
            # print ("copy %s %s" % (dl_file, export_path))
            assert shutil.copy(self.download_path, export_path)
            
    def __str__(self):
        return ("%s\t/\t%s" % (self.plex_track.title, self.plex_track.grandparentTitle))

os.makedirs(DOWNLOAD_TMP, exist_ok=True)

for export_tracklist in export_tracklists:
    export_tracklist.export(export_base_directory)

print("**** All done!")#%d tracks downloaded to %s (of which %d were transcoded to %s)" % (len(downloaded_files), export_base_directory, len(transcode_input_files), transcode_extension))
